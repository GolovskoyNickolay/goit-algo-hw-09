### Приклади використання:

Для суми **113** обидва алгоритми, жадібний та динамічного програмування, повернули однаковий результат:

- **Жадібний алгоритм:** `{50: 2, 10: 1, 2: 1, 1: 1}`
- **Алгоритм динамічного програмування:** `{50: 2, 10: 1, 2: 1, 1: 1}`

### Порівняння алгоритмів

#### 1. **Жадібний алгоритм**
- **Часова складність:** \(O(n)\), де \(n\) – кількість номіналів монет.  
- **Переваги:** Простий у реалізації та швидкий на практиці. Для добре підібраних номіналів (як у нашому прикладі) повертає оптимальний результат.
- **Недоліки:** Не завжди гарантує мінімальну кількість монет для всіх можливих наборів монет. Наприклад, якщо набір монет був би [9, 6, 1], жадібний підхід міг би повернути неоптимальний результат.

#### 2. **Алгоритм динамічного програмування**
- **Часова складність:** \(O(n \cdot m)\), де \(n\) – кількість номіналів монет, а \(m\) – сума, для якої ми шукаємо рішення.  
- **Переваги:** Гарантує мінімальну кількість монет для будь-якого набору номіналів.
- **Недоліки:** Витрачає більше часу та пам'яті, особливо для великих сум.

#### Висновок
- **Жадібний алгоритм** є більш ефективним для практичного використання, коли набір монет добре підібраний.
- **Алгоритм динамічного програмування** краще підходить для складніших випадків, де набір монет може бути нестандартним, і гарантує мінімальну кількість монет.

### Рекомендація
Для касових апаратів із типовими наборами монет (як у нашому прикладі) жадібний алгоритм є більш доцільним, оскільки він працює швидше і вимагає менше пам'яті. Проте для більш загальних випадків, коли набір монет може бути довільним, варто застосовувати алгоритм динамічного програмування.
